import { H264Decoder } from './H264Decoder.js';
import LibavH264 from './libav-h264.js';
const h264Decoders = {};
export function init() {
    return LibavH264().then((LibavH264) => {
        self.addEventListener('message', (e) => {
            // @ts-ignore
            const message = e.data;
            const renderStateId = message.renderStateId;
            const messageType = message.type;
            switch (messageType) {
                case 'decode': {
                    let decoder = h264Decoders[renderStateId];
                    if (!decoder) {
                        decoder = new H264Decoder(LibavH264, (output, width, height) => {
                            postMessage({
                                type: 'pictureReady',
                                width,
                                height,
                                renderStateId,
                                data: output,
                            }, [output.yPlane.buffer, output.uPlane.buffer, output.vPlane.buffer]);
                        });
                        h264Decoders[renderStateId] = decoder;
                    }
                    decoder.decode(new Uint8Array(message.data, message.offset, message.length));
                    break;
                }
                case 'release': {
                    const decoder = h264Decoders[renderStateId];
                    if (decoder) {
                        decoder.release();
                        delete h264Decoders[renderStateId];
                    }
                    break;
                }
                case 'closeFrame': {
                    const decoder = h264Decoders[renderStateId];
                    if (decoder) {
                        decoder.closeFrame(message.data);
                    }
                    break;
                }
            }
        }, { passive: true });
        self.postMessage({ type: 'decoderReady' });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSDI2NFdvcmtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9IMjY0V29ya2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUE7QUFDM0MsT0FBTyxTQUFTLE1BQU0sY0FBYyxDQUFBO0FBdUJwQyxNQUFNLFlBQVksR0FBZ0MsRUFBRSxDQUFBO0FBRXBELE1BQU0sVUFBVSxJQUFJO0lBQ2xCLE9BQU8sU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBb0IsRUFBRSxFQUFFO1FBQy9DLElBQUksQ0FBQyxnQkFBZ0IsQ0FDbkIsU0FBUyxFQUNULENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDSixhQUFhO1lBQ2IsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQTtZQUN0QixNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFBO1lBQzNDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUE7WUFDaEMsUUFBUSxXQUFXLEVBQUU7Z0JBQ25CLEtBQUssUUFBUSxDQUFDLENBQUM7b0JBQ2IsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFBO29CQUN6QyxJQUFJLENBQUMsT0FBTyxFQUFFO3dCQUNaLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFOzRCQUM3RCxXQUFXLENBQ1Q7Z0NBQ0UsSUFBSSxFQUFFLGNBQWM7Z0NBQ3BCLEtBQUs7Z0NBQ0wsTUFBTTtnQ0FDTixhQUFhO2dDQUNiLElBQUksRUFBRSxNQUFNOzZCQUNiLEVBQ0QsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUNuRSxDQUFBO3dCQUNILENBQUMsQ0FBQyxDQUFBO3dCQUNGLFlBQVksQ0FBQyxhQUFhLENBQUMsR0FBRyxPQUFPLENBQUE7cUJBQ3RDO29CQUNELE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFBO29CQUM1RSxNQUFLO2lCQUNOO2dCQUNELEtBQUssU0FBUyxDQUFDLENBQUM7b0JBQ2QsTUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFBO29CQUMzQyxJQUFJLE9BQU8sRUFBRTt3QkFDWCxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUE7d0JBQ2pCLE9BQU8sWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFBO3FCQUNuQztvQkFDRCxNQUFLO2lCQUNOO2dCQUNELEtBQUssWUFBWSxDQUFDLENBQUM7b0JBQ2pCLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQTtvQkFDM0MsSUFBSSxPQUFPLEVBQUU7d0JBQ1gsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBYyxDQUFDLENBQUE7cUJBQzNDO29CQUNELE1BQUs7aUJBQ047YUFDRjtRQUNILENBQUMsRUFDRCxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FDbEIsQ0FBQTtRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQTtJQUM1QyxDQUFDLENBQUMsQ0FBQTtBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIMjY0RGVjb2RlciB9IGZyb20gJy4vSDI2NERlY29kZXInXG5pbXBvcnQgTGliYXZIMjY0IGZyb20gJy4vbGliYXYtaDI2NCdcblxuZXhwb3J0IHR5cGUgbGliYXZoMjY0ID0ge1xuICByZWFkb25seSBIRUFQVTg6IFVpbnQ4QXJyYXlcbiAgX21hbGxvYyhieXRlczogbnVtYmVyKTogbnVtYmVyXG4gIF9mcmVlKHB0cjogbnVtYmVyKTogdm9pZFxuICBfZGVjb2RlKFxuICAgIGNvZGVjQ29udGV4dDogbnVtYmVyLFxuICAgIGRhdGFJbjogbnVtYmVyLFxuICAgIGRhdGFJblNpemU6IG51bWJlcixcbiAgICB5UGxhbmVPdXQ6IG51bWJlcixcbiAgICB1UGxhbmVPdXQ6IG51bWJlcixcbiAgICB2UGxhbmVPdXQ6IG51bWJlcixcbiAgICB3aWR0aE91dDogbnVtYmVyLFxuICAgIGhlaWdodE91dDogbnVtYmVyLFxuICAgIHN0cmlkZU91dDogbnVtYmVyLFxuICApOiBudW1iZXJcbiAgZ2V0VmFsdWUoYWRkcmVzczogbnVtYmVyLCBhZGRyZXNzVHlwZTogc3RyaW5nKTogbnVtYmVyXG4gIF9jcmVhdGVfY29kZWNfY29udGV4dCgpOiBudW1iZXJcbiAgX2Rlc3Ryb3lfY29kZWNfY29udGV4dChfY29kZWNDb250ZXh0OiBudW1iZXIpOiB2b2lkXG4gIF9jbG9zZV9mcmFtZShmcmFtZVB0cjogbnVtYmVyKTogdm9pZFxufVxuXG5jb25zdCBoMjY0RGVjb2RlcnM6IFJlY29yZDxzdHJpbmcsIEgyNjREZWNvZGVyPiA9IHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICByZXR1cm4gTGliYXZIMjY0KCkudGhlbigoTGliYXZIMjY0OiBsaWJhdmgyNjQpID0+IHtcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnbWVzc2FnZScsXG4gICAgICAoZSkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGFcbiAgICAgICAgY29uc3QgcmVuZGVyU3RhdGVJZCA9IG1lc3NhZ2UucmVuZGVyU3RhdGVJZFxuICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lc3NhZ2UudHlwZVxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnZGVjb2RlJzoge1xuICAgICAgICAgICAgbGV0IGRlY29kZXIgPSBoMjY0RGVjb2RlcnNbcmVuZGVyU3RhdGVJZF1cbiAgICAgICAgICAgIGlmICghZGVjb2Rlcikge1xuICAgICAgICAgICAgICBkZWNvZGVyID0gbmV3IEgyNjREZWNvZGVyKExpYmF2SDI2NCwgKG91dHB1dCwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGljdHVyZVJlYWR5JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogb3V0cHV0LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtvdXRwdXQueVBsYW5lLmJ1ZmZlciwgb3V0cHV0LnVQbGFuZS5idWZmZXIsIG91dHB1dC52UGxhbmUuYnVmZmVyXSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGgyNjREZWNvZGVyc1tyZW5kZXJTdGF0ZUlkXSA9IGRlY29kZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS5vZmZzZXQsIG1lc3NhZ2UubGVuZ3RoKSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JlbGVhc2UnOiB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gaDI2NERlY29kZXJzW3JlbmRlclN0YXRlSWRdXG4gICAgICAgICAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgICAgICAgICBkZWNvZGVyLnJlbGVhc2UoKVxuICAgICAgICAgICAgICBkZWxldGUgaDI2NERlY29kZXJzW3JlbmRlclN0YXRlSWRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdjbG9zZUZyYW1lJzoge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IGgyNjREZWNvZGVyc1tyZW5kZXJTdGF0ZUlkXVxuICAgICAgICAgICAgaWYgKGRlY29kZXIpIHtcbiAgICAgICAgICAgICAgZGVjb2Rlci5jbG9zZUZyYW1lKG1lc3NhZ2UuZGF0YSBhcyBudW1iZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgIClcblxuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiAnZGVjb2RlclJlYWR5JyB9KVxuICB9KVxufVxuIl19